% xelatex -shell-escape main.tex
\documentclass[landscape, twocolumn, a4paper]{article}

\input{config.tex}

\begin{document}
\begin{titlepage}
\onecolumn
% \begin{figure*}[h]
% 	\centering
% 	\includegraphics[scale=0.5]{others/Peking_University_logo.png}
% \end{figure*}
% 
% 
% \begin{center}
% 	\Huge 这是封面
% \end{center}

%\begin{center}
%    \includesvg{name/r.svg}
%    \includesvg{name/o.svg}
%    \includesvg{name/y.svg}
%    \includesvg{name/g.svg}
%    \includesvg{name/b.svg}
%    \includesvg{name/p.svg}
%\end{center}


% \vspace*{3cm}
% {\LARGE
% \centering
% \begin{tabular}{ccc@{\hspace{1.5cm}}ccc}
% \multicolumn{3}{c}{Coach} & \multicolumn{3}{c}{Contestant} \\
% 张勤建 & & 罗国杰 & 钱易 & 彭博 & 冯施源 \\
% Qinjian Zhang & & Guojie Luo & Yi Qian & Bo Peng & Shiyuan Feng \\
% \end{tabular}
% }


% \center\fontsize{20.0pt}{\baselineskip}\selectfont ICPC World Finals Luxor 

\thispagestyle{empty}
\pagebreak
\end{titlepage}

% ===== 页面样式 =====
\pagestyle{fancy}
% \lhead{\large Peking University-Let it Rot}
\rhead{\Huge \thepage}

% ===== 三栏目录页 =====
\clearpage
\onecolumn
\begin{center}
  \vspace*{-1em}
  {\Huge \bfseries Contents}\\[1em]
\end{center}

\begin{spacing}{0.75}
\begin{small}
\begin{multicols}{3}
\setcounter{tocdepth}{3}
\tableofcontents
\end{multicols}
\end{small}
\end{spacing}

% ===== 回到两栏正文 =====
\clearpage
\twocolumn

\section{图论}

\subsection{二分图匹配}
\codesectiondesc{\subsubsection}{cpp}{contents/graph/matching/dfs-matching.cpp}{二分图最大匹配 | 最小边覆盖}{左到右连单向边，时间复杂度 $O(M|match|)$。}

\codesectiondesc{\subsubsection}{cpp}{contents/graph/matching/bitset-dfs-matching.cpp}{二分图最大匹配 (bitset 优化)}{左到右连单向边，时间复杂度 $O(n^2/w\ |match|)$。}

\codesectiondesc{\subsubsection}{cpp}{contents/graph/matching/HK.cpp}{二分图最大匹配 (Hopcroft-Karp) \& 最小边覆盖}{左到右单向边，时间复杂度 $O(M \sqrt{|match|})$}

\codesectiondesc{\subsubsection}{cpp}{contents/graph/matching/KM.cpp}{二分图最小权匹配}{返回左边每个点匹配的右边点的编号，左边的点不多于右边的点（必要时补点）。}
\codesectiondesc{\subsubsection}{cpp}{contents/graph/matching/newkm.cpp}{二分图最小权匹配2}{ 最小权匹配。返回代价和、右边每个点匹配的左边点的编号、对应的边权。过程中能计算出匹配为 $0 \cdots |match|$ 的最优解。\par 时间复杂度 $O(|match|(L^2+|E|))$。 }

\codesectiondesc{\subsection}{cpp}{contents/graph/old_dinic.cpp}{网络最大流 (dinic)}{}

\codesectiondesc{\subsection}{cpp}{contents/graph/dinic.cpp}{网络最大流 (dinic) 2}{这是 vector 版本，但不知道为什么很多情况不会快。至少清空好搞，没有经过严谨测试。}

\codesectiondesc{\subsection}{cpp}{contents/graph/MCMF.cpp}{最小费用流}{}

\codesectiondesc{\subsection}{cpp}{contents/graph/带花树.cpp}{一般图最大匹配 (带花树)}{edge 里存双向边。运行结束后 match 存放每个点匹配的点的编号，如果没有匹配则为 $0$。}

\codesectiondesc{\subsection}{cpp}{contents/graph/D-MST.cpp}{最小树形图}{用 DMST::link 添加边，然后调用 DMST::solve(root) 得到最小树形图边的集合，如果没有合法解会返回空集 (注意 $n=1$)。}

\codesectiondesc{\subsection}{cpp}{contents/graph/kosaraju.cpp}{强连通分量 (kosaraju)}{e 存有向边，re 里存反向边。用 solve 得到所有强连通分量。时间复杂度 $O(\frac{n^2}{w})$。}

\codesectiondesc{\subsection}{cpp}{contents/graph/eulerwalk.cpp}{欧拉回路/欧拉路径}{如果是无向图，两个方向都连边，id 相同。不同的边 id 不同且在 $[1, m]$ 里。 \par src 是起点，如果是欧拉路径，找一个度数为奇数(无向图)/出度大于入度(有向图)的点作为 src，如果是回路，选一个度数非零的点作为 src。 \par 如果有解，求出路径是 $s$，那么返回 $[(s_1 = src, -1), (s_2, id(s_1 \rightarrow s_2)), \ldots, (s_n, id(s_{n-1} \rightarrow s_n))]$，如果是回路，那么 $s_n = s_1 = src$。无解则返回空集。}

\codesectiondesc{\subsection}{cpp}{contents/graph/支配树.cpp}{支配树}{}

% \subsection{缩点 | Tarjan} % !!! pb
% \inputminted{cpp}{contents/graph/tarjan.cpp}
% ... (omitted commented out sections)

\subsection{Tree And Graph}
\input{contents/graph/TreeAndGraph.tex}

\section{数论}	

\codesectiondesc{\subsection}{cpp}{contents/numbertheory/approx.cpp}{取模还原分数}{}

\codesectiondesc{\subsection}{cpp}{contents/numbertheory/exgcd.cpp}{扩展欧几里得}{结果的 $x, y$ 满足：$ax + by = \gcd(a, b)$; 若 $a, b$ 非 $0$，则： $-b \leq x \leq b, -a \leq y \leq a$。}

\codesectiondesc{\subsection}{cpp}{contents/numbertheory/Euclid.cpp}{万能欧几里得}{}

\codesectiondesc{\subsection}{cpp}{contents/numbertheory/floor_sum.cpp}{floor-sum}{$n < 2 ^ {32}, 1 \leq m < 2 ^ {32}$ \par $$ result=\sum_{i=0}^{n-1} \lfloor \frac{ai + b}{m} \rfloor \pmod{2^{63}} $$}

\codesectiondesc{\subsection}{cpp}{contents/numbertheory/minmod.cpp}{Min of Mod of Linear}{$$ result=\min_{0 \leq i < n} \{ (a i + b) \% m \} $$}

\codesectiondesc{\subsection}{cpp}{contents/numbertheory/sbt.cpp}{Stern-Brocot Tree 二分}{}

\codesectiondesc{\subsection}{cpp}{contents/numbertheory/CRT.cpp}{中国剩余定理}{返回满足 $x \equiv a_i \pmod{m_i} (i = 1, 2)$ 的最小非负整数 $x$，若无解则返回 $-1$。}

\codesectiondesc{\subsection}{cpp}{contents/numbertheory/Miller_Rabin.cpp}{Miller-Rabin}{调用 checkprime 判断是否为质数。}

\codesectiondesc{\subsection}{cpp}{contents/numbertheory/pollard_rho.cpp}{Pollard-rho}{调用 factor 获得 $x$ 质因子的可重集合（已从小到大排序）。}

\codesectiondesc{\subsection}{cpp}{contents/numbertheory/quadres.cpp}{二次剩余}{quadres 用于判断是否存在二次剩余，sqrtp 用于计算结果。$p$ 或 $b$ 需要是质数（或者 $1$）。\par 高斯引理： $$ \left( \frac{a}{p} \right) = (-1)^{\sum_{i=1}^{\frac{p-1}{2}} \mathbf{1}[(ai \bmod p) > p/2]} $$ \par 推论： $$ \begin{cases} \left( \frac{-1}{p} \right) = 1 & \Leftrightarrow p \equiv 1 \pmod{4}, \\ \left( \frac{2}{p} \right) = 1 & \Leftrightarrow p \equiv \pm 1 \pmod{8}, \\ \left( \frac{3}{p} \right) = 1 & \Leftrightarrow p \equiv \pm 1 \pmod{12}, \\ \left( \frac{5}{p} \right) = 1 & \Leftrightarrow p \equiv \pm 1 \pmod{5}. \end{cases} $$}

\section{Math}

\subsection{\href{run:./contents/math/拉格朗日反演.cpp}{拉格朗日反演}}
$$
\begin{aligned}
G(F(x))&=H(x)\Rightarrow [x^n]G(x)=\frac{1}{n}[u^{n-1}]H'(u)(\frac{u}{F(u)})^n\\
G(F(x))&=x\Rightarrow [x^n]H(G(x))=\frac{1}{n}[u^{n-1}]H'(u)(\frac{u}{F(u)})^n\\
G(F(x))&=x\Rightarrow [x^n]G^k(x)=\frac{k}{n}[u^{n-k}](\frac{u}{F(u)})^n
\end{aligned}
$$

\subsection{\href{run:./contents/math/分拆数五边形数.cpp}{分拆数|五边形数}}
$$
\prod_{i \ge 1} (1 - x ^ i)= \sum_{k = -\infty} ^ {\infty} (-1) ^ k x ^ {\frac{k(3k-1)}{2}}
$$

\codesectiondesc{\subsection}{cpp}{contents/math/FFT.cpp}{Fast Fourier Transform}{}

\codesectiondesc{\subsection}{cpp}{contents/math/NTT.cpp}{Number Theoretic Transform}{}

\codesectiondesc{\subsection}{cpp}{contents/math/GF_noExp.cpp}{Generating function}{}

\codesectiondesc{\subsection}{cpp}{contents/math/online_convolution.cpp}{全在线卷积}{}

\codesectiondesc{\subsection}{cpp}{contents/math/poly-composition.cpp}{多项式复合}{ $res(x) = f(g(x)) \bmod x^n$，$g(0) = 0$, $deg(f), deg(g) < n$。}

\subsection{常系数线性递推}

\codesectiondesc{\subsubsection}{cpp}{contents/math/BM.cpp}{Berlekamp Massey}{返回最短的 $c$ 使得： $\forall n \geq size(c) : a_n = \sum_{i=0}^{size(c)-1} c_i a_{n-1-i}$}

\codesectiondesc{\subsubsection}{cpp}{contents/math/线性递推形式转换.cpp}{递推式转分式}{$$ a_i = \sum_{j=1}^{d} c_j a_{i-j}, i \geq d \Leftrightarrow a_i = \left\lbrack x^i \right\rbrack \frac{p(x)}{q(x)} $$}

\codesectiondesc{\subsubsection}{cpp}{contents/math/bostan_mori.cpp}{Bostan–Mori}{$$ \left\lbrack x^k\right\rbrack \frac{p(x)}{q(x)} $$}

\codesectiondesc{\subsubsection}{cpp}{contents/math/Fiduccia.cpp}{远处区间值}{$$ \left\lbrack x^{\left\lbrack k,k+m\right)}\right\rbrack \frac{p(x)}{q(x)}$$ \par 如果 $deg(p) \geq deg(q)$, 请使用 solve\_x，不然可以直接使用 solve。}

\codesectiondesc{\subsection}{cpp}{contents/math/LP.cpp}{线性规划 (单纯形法)}{$x[1\cdots n]$ 是变量，$a[1\cdots m][\cdots]$ 是约束。\par 所有约束为： $$ \begin{aligned} \forall i \in [1, m] &: a[i][0] + \sum_{j=1}^{n} a[i][j] x[j] \geq 0 \\ \forall j \in [1, n] &: x[j] \geq 0 \end{aligned} $$ \par 最大化 $$ \sum_{j=1}^{n} a[0][j] x[j] $$ \par 如果无解返回 nan，如果无界返回 inf。最后的 $x$ 里存放的是最优解。}

\codesectiondesc{\subsection}{cpp}{contents/math/Goldensectionsearch.cpp}{黄金三分}{返回 $f$ 在 $[min(a, c), max(a, c)]$ 上的极大值点 (f 需要是单峰函数)。}
\codesectiondesc{\subsection}{cpp}{contents/math/charpoly.cpp}{特征多项式}{$ans_i = [\lambda^i] \det(\lambda I - A)$。}
\codesectiondesc{\subsection}{cpp}{contents/math/det(a+bx).cpp}{det(A + B x)}{$ans_i = [x^i] \det(A + B x)$，要抄特征多项式。}

\section{字符串}

\codesectiondesc{\subsection}{cpp}{contents/string/SAM.cpp}{后缀自动机 SAM}{需要两倍点数量。}

\codesectiondesc{\subsection}{cpp}{contents/string/PAM.cpp}{回文自动机 PAM}{}

\codesectiondesc{\subsection}{cpp}{contents/string/pamdp.cpp}{回文自动机 PAM dp}{ atom 要赋值，然后 query 是 pam id, seq id，都要问。结果是 $\sum_{s[i:seq id+1] is palindrome} atom[i - 1]$}

\codesectiondesc{\subsection}{cpp}{contents/string/AC自动机.cpp}{AC 自动机}{}

\codesectiondesc{\subsection}{cpp}{contents/string/SA.cpp}{SA}{后缀数组， $sa$ 是个 $0 \sim n-1$ 的排列，$h[i] = lcp(s[sa[i]:], s[sa[i+1]:])$。}

\codesectiondesc{\subsection}{cpp}{contents/string/Zalgo.cpp}{Z algorithm}{返回的 $lcp[i] = lcp(s, s[i:])$。}

\codesectiondesc{\subsection}{cpp}{contents/string/manacher.cpp}{Manacher}{返回每个回文中心的回文半径大小，奇偶分开考虑。}

\codesectiondesc{\subsection}{cpp}{contents/string/minrep.cpp}{最小表示法}{返回 $s$ 的最小表示的起始位置。可以用 rotate 算出最小表示的字符串。}

\codesectiondesc{\subsection}{cpp}{contents/string/lyndon.cpp}{Lyndon 分解}{}


\section{数据结构}
\codesectiondesc{\subsection}{cpp}{contents/ds/ex-bit.cpp}{区间加区间求和 树状数组}{add 区间加，query 区间求和。区间都是闭区间。}

\codesectiondesc{\subsection}{cpp}{contents/ds/zkw-sgt.cpp}{zkw 线段树}{单点修改区间半群。如果半群没有单位元可以用 qry2。}

\codesectiondesc{\subsection}{cpp}{contents/ds/rangequery.cpp}{静态区间半群}{$O(n \log n)$ 预处理，$O(1)$ 查询。}

\codesectiondesc{\subsection}{cpp}{contents/ds/LCT.cpp}{Link Cut Tree}{}

\codesectiondesc{\subsection}{cpp}{contents/ds/btrie.cpp}{压位 Trie}{}

\codesectiondesc{\subsection}{cpp}{contents/ds/pbds_tree.cpp}{pbds tree}{}


\section{geometry}
\codesectiondesc{\subsection}{cpp}{contents/geometry/向量.cpp}{向量}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/centers.cpp}{三角形各心}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/直线半平面.cpp}{直线半平面}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/半平面交.cpp}{半平面交}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/线段.cpp}{线段}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/简单多边形.cpp}{简单多边形}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/简单多边形三角剖分.cpp}{简单多边形三角剖分}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/seg_in_polygon.cpp}{线段 in 多边形}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/图形交.cpp}{图形求交}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/凸包.cpp}{凸包}{结果为逆时针。}
\codesectiondesc{\subsection}{cpp}{contents/geometry/上凸壳.cpp}{上凸壳}{结果显然为顺时针。}
\codesectiondesc{\subsection}{cpp}{contents/geometry/最小圆覆盖.cpp}{最小圆覆盖}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/最近点对.cpp}{最近点对}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/凸包直径.cpp}{凸包直径}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/切凸包.cpp}{切凸包}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/voronoi.cpp}{V 图}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/Delaunay.cpp}{Delaunay 三角剖分}{}

\section{geometry3d}
\codesectiondesc{\subsection}{cpp}{contents/geometry/3d/vector.cpp}{向量}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/3d/plane.cpp}{平面}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/3d/line.cpp}{直线}{}
\codesectiondesc{\subsection}{cpp}{contents/geometry/3d/convex.cpp}{凸包}{}


\section{Misc}
\codesectiondesc{\subsection}{cpp}{contents/misc/pragma.cpp}{Pragma}{}
\codesectiondesc{\subsection}{cpp}{contents/misc/Barrett.cpp}{Barrett}{}
\codesectiondesc{\subsection}{cpp}{contents/misc/fastdivcheck.cpp}{快速整除判定}{要求 $p$ 是奇数。如果是 (u)int128，求逆循环次数要改成 $6$。}
\codesectiondesc{\subsection}{cpp}{contents/misc/lcs.cpp}{LCS}{}
\codesectiondesc{\subsection}{cpp}{contents/misc/zeller.cpp}{日期公式}{getday 返回自 $1/1/1$ 起到 $y/m/d$ 的天数，$1/1/1$ 是星期一，所以模 $7$ 可以得算出是周几。\par date 是 getday 的逆。}
\codesectiondesc{\subsection}{cpp}{contents/misc/xorshift.cpp}{Xorshift}{}

\subsection{distributions}

\codesectiondesc{\subsection}{py}{contents/misc/template.py}{python}{}
\codesectiondesc{\subsection}{text}{contents/misc/ieee754.txt}{浮点数精度}{}


\section{配置}

\subsection{vimrc}
\inputminted{cpp}{contents/config/.vimrc}

\subsection{bashrc}
\inputminted{cpp}{contents/config/.bashrc}

\subsection{对拍}
需要 chmod +x
\inputminted{cpp}{contents/config/1.sh}

\subsection{编译参数}
\inputminted{text}{contents/tables/options.txt}

\subsection{随机素数}
\inputminted{text}{contents/tables/primes.txt}

\subsection{常数表}
\input{contents/tables/Addon.tex}


\section{注意事项}
\subsection{测试项目}
pbds tree,
float128, int128, long double,
submit 命令,
printfile,
MLE ?= RE,
pragma,
axv2,
python,

测试代码长度限制,尝试触发 NO-OUTPUT, OUTPUT-LIMIT, RUN-ERROR
\newline
\subsection{bugs}
看数据范围（多测总和）,
变量 shadow,
清空,
long long,
数组大小,
模数,
MLE?,
对拍记得看输出在不在变,
输出格式，
inf 开小，
答案初值，
STL 重构导致引用失效，
极端情况(n=1)
\newline
\onecolumn
\newpage

\begin{multicols}{3}
\section{tables}
\subsection{导数积分}
\input{contents/math/CalculusTable.tex}
\input{contents/math/IntegrationTable_NewMeta.tex}
\end{multicols}


\end{document}